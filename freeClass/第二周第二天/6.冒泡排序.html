<html>
<head>
    <meta charset="UTF-8">
    <title>冒泡排序</title>
</head>
<body>
<script type="text/javascript">
    //    var ary = [4, 3, 5, 2, 1];
    //->[1, 2, 3, 4, 5]
    //->冒泡排序的思想：让当前项和后一项进行比较，如果当前项大于后一项,两者交换位置
    //第一轮:
    //4>3 交换位置 [3, 4, 5, 2, 1]
    //4<5 不需要交换位置 [3, 4, 5, 2, 1]
    //5>2 交换位置 [3, 4, 2, 5, 1]
    //5>1 交换位置 [3, 4, 2, 1, 5]
    //->虽然没有实现最后的目标,但是已经把数组中当前最大的那个值5已经放在数组的末尾位置了
    //->第一轮比较了四次 一共五个数,不用和自己比,最多比较四次
    //第二轮
    //3<4 不交换 [3, 4, 2, 1, 5]
    //4>2 交换 [3, 2, 4, 1, 5]
    //4>1 交换 [3, 2, 1, 4, 5]
    //->也没有实现最后的目标,但是把剩余项中最大的那个4放在倒数第二位了
    //->第一轮比较了三次 首先不用和自己比,最多四次,但是第一轮我们已经把最大的一个数放末尾了,不需要再和末尾的5比了
    //第三轮
    //3>2 交换 [2, 3, 1, 4, 5]
    //3>1 交换 [2, 1, 3, 4, 5]
    //->第一轮比较了两次 首先不用和自己比,最多四次,但是第一轮/第二轮我们已经把最大的两个数放末尾了,不需要再和末尾的4/5比了
    //第四轮
    //2>1 交换 [1, 2, 3, 4, 5]
    //每一轮当前项和后一项两两比较的话,虽然不一定达到最后的目标结果,但是已经把当前最大的那个值放在后面了 ->数组一共有五项,我只需要比较四轮,把四个最大值分别的放在末尾,就实现了排序 ->一共最多需要比较多少轮:ary.length-1
    //->i轮数 i=0  i<ary.length-1
    //->j每一轮比较的次数
    //i=0 第一轮 4 ary.length-1-0  ary.length-1->不用和自己比
    //i=1 第二轮 3 ary.length-1-1
    //i=2 第三轮 2 ary.length-1-2
    //i=3 第四轮 1 ary.length-1-3
    //...
    //每一轮比较的次数 ary.length-1-i
    //->两者交换位置
    //    var a = 12;
    //    var b = 13;
    //    var c = null;
    //    c = a;
    //    a = b;
    //    b = c;
    //    console.log(a,b);//->13,12
    //->如果不能使用第三个空瓶子如何处理?
    //    var a = 12;
    //    var b = 13;
    //    a = a + b;//->a=25
    //    b = a - b;//b=25-13=12
    //    a = a - b;//a=25-12=13
    //    function bubbleSort(ary) {
    //        var temp = null;
    //        for (var i = 0; i < ary.length - 1; i++) {//i->轮数
    //            for (var j = 0; j < ary.length - 1 - i; j++) {//j->每一轮比较的次数
    //                if (ary[j] > ary[j + 1]) {
    //                    temp = ary[j];
    //                    ary[j] = ary[j + 1];
    //                    ary[j + 1] = temp;
    //                }
    //            }
    //        }
    //        return ary;
    //    }
    //    var ary = [4, 3, 5, 2, 1];
    //    var res = bubbleSort(ary);
    //    console.log(res);
    //->优化
    var ary = [2, 1, 3, 5, 4];
    //在第一轮比较前设置一个变量等于false ->var flag = false;
    //第一轮 i=0
    //2>1 [1, 2, 3, 5, 4] 只要有需要交换位置的 我就让flag=true
    //2<3 [1, 2, 3, 5, 4]
    //3<5 [1, 2, 3, 5, 4]
    //5>4 [1, 2, 3, 4, 5]
    //->flag=true 说明上一轮有交换的了,我继续执行下一轮
    //->在第二轮开始之前,我在让flag等于false
    //第二轮 i=1
    //1<2 [1, 2, 3, 4, 5]
    //2<3 [1, 2, 3, 4, 5]
    //3<4 [1, 2, 3, 4, 5]
    //->flag=false 当前第二轮一个都没有交换，说明数组已经排序好了,没必要在往下比较其它的轮数了，我们结束循环即可
    function bubbleSort(ary) {
        var flag = false;
        for (var i = 0; i < ary.length - 1; i++) {
            for (var j = 0; j < ary.length - 1 - i; j++) {
                if (ary[j] > ary[j + 1]) {
                    ary[j] = ary[j] + ary[j + 1];
                    ary[j + 1] = ary[j] - ary[j + 1];
                    ary[j] = ary[j] - ary[j + 1];
                    flag = true;//->只要本轮有交换就让flag=true
                }
            }
            if (flag) {//->flag==true 上一轮有交换的,继续执行下一轮,并且让flag重新的赋值false
                flag = false;
            } else {//->上一轮没有交换的,已经排好序了,直接结束循环即可
                break;
            }
        }
        return ary;
    }
    console.log(bubbleSort([2, 1, 3, 5, 4]));
</script>
</body>
</html>